

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>PLAYTEST - Trivial Mode</title>

    <!-- Embedded Global Stylesheet -->
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      }
      .animate-fade-in { animation: fadeIn 0.5s ease-in-out; }
      @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
      .animate-pop-in { animation: popIn 0.3s ease-out; }
      @keyframes popIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #1B263B; border-radius: 10px; }
      ::-webkit-scrollbar-thumb { background: #415A77; border-radius: 10px; }
      ::-webkit-scrollbar-thumb:hover { background: #778DA9; }
      * { scrollbar-width: thin; scrollbar-color: #415A77 #1B263B; }
    </style>

    <!-- Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': '#0D1B2A',
              'brand-secondary': '#1B263B',
              'brand-tertiary': '#415A77',
              'brand-accent': '#778DA9',
              'brand-light': '#E0E1DD',
              'brand-cta': '#3B82F6',
              'brand-cta-hover': '#2563EB',
              'brand-success': '#10B981',
              'brand-danger': '#EF4444',
            },
          },
        },
      };
    </script>

    <!-- Import Map to resolve bare module specifiers for React -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-dom/": "https://esm.sh/react-dom@18.2.0/",
    "react/": "https://esm.sh/react@18.2.0/"
  }
}
</script>
  </head>
  <body class="bg-brand-primary text-brand-light">
    <div id="root"></div>

    <!-- Babel Standalone for in-browser transpilation of TSX/JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Main application script -->
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback, useMemo, useRef, createContext, useContext } from 'react';
      import ReactDOM from 'react-dom/client';

      // --- INLINED: i18n ---
      const translations = {
        es: {
          header_title: 'Aplicación PLAYTEST', header_subtitle: 'La forma más divertida de estudiar', language: 'Idioma', english: 'Inglés', spanish: 'Español',
          all_blocks_return: 'Volver',
          generic_cancel: 'Cancelar', error: 'Error', loading: 'Cargando...',
          footer_text: '© 2024 PLAYTEST. Todos los derechos reservados.',
          game_select_answer: 'Selecciona una respuesta',
          game_finish_confirm_title: '¿Finalizar Partida?', game_finish_confirm_message: '¿Seguro que quieres terminar la partida? Tu progreso actual se mostrará en la pantalla de resultados.',
          game_button_finish: 'Finalizar', game_button_play_again: 'Jugar de Nuevo', game_button_dashboard: 'Volver al Panel',
          delete_question_prompt_confirm: 'SI', delete_question_prompt_cancel: 'NO',
          game_trivial_desc: 'Los jugadores eligen temas para ganar "fichas". Gana el primero que consiga una ficha de cada tema.',
          game_choose_topic: 'Elige un Tema', game_player_turn: 'Turno de {playerNickname}',
          game_wedge_earned: '¡Ficha Conseguida!', game_turn_again: '¡Te toca otra vez!', game_turn_ends: 'Fin del turno.',
          game_winner_announcement: '¡{nickname} ha ganado!',
          game_results_title: '¡Partida Terminada!',
          game_stats_wedges: 'Fichas', game_stats_turns: 'Turnos', game_stats_rounds: 'Rondas',
          game_stats_most_hit_topic: 'Tema más acertado', game_stats_most_missed_topic: 'Tema más fallado',
          game_feedback_correct: '¡Correcto!', game_feedback_incorrect: '¡Incorrecto!',
          game_continue_button: 'Continuar', game_no_more_questions: 'No quedan preguntas en este tema. Elige otro.',
          game_stats_total_time: 'Tiempo Total',
        },
        en: {
          header_title: 'PLAYTEST App', header_subtitle: 'The most fun way to study', language: 'Language', english: 'English', spanish: 'Spanish',
          all_blocks_return: 'Return',
          generic_cancel: 'Cancel', error: 'Error', loading: 'Loading...',
          footer_text: '© 2024 PLAYTEST. All rights reserved.',
          game_select_answer: 'Select an answer',
          game_finish_confirm_title: 'Finish Game?', game_finish_confirm_message: 'Are you sure you want to end the game? Your current progress will be shown on the results screen.',
          game_button_finish: 'Finish', game_button_play_again: 'Play Again', game_button_dashboard: 'Back to Dashboard',
          delete_question_prompt_confirm: 'YES', delete_question_prompt_cancel: 'NO',
          game_trivial_desc: 'Players choose topics to win "wedges". The first to collect a wedge from every topic wins.',
          game_choose_topic: 'Choose a Topic', game_player_turn: "{playerNickname}'s Turn",
          game_wedge_earned: 'Wedge Earned!', game_turn_again: 'You get another turn!', game_turn_ends: 'Turn ends.',
          game_winner_announcement: '{nickname} wins!',
          game_results_title: 'Game Over!',
          game_stats_wedges: 'Wedges', game_stats_turns: 'Turns', game_stats_rounds: 'Rondas',
          game_stats_most_hit_topic: 'Most Successful Topic', game_stats_most_missed_topic: 'Most Missed Topic',
          game_feedback_correct: 'Correct!', game_feedback_incorrect: 'Incorrect!',
          game_continue_button: 'Continue', game_no_more_questions: 'No questions left in this topic. Pick another one.',
          game_stats_total_time: 'Total Time',
        }
      };
      const LanguageContext = createContext();
      const LanguageProvider = ({ children }) => {
        const [language, setLanguage] = useState(() => localStorage.getItem('playtest_lang') || 'es');
        useEffect(() => { localStorage.setItem('playtest_lang', language); }, [language]);
        const t = useCallback((key, replacements = {}) => {
            let translation = translations[language]?.[key] || translations['en']?.[key] || key;
            Object.keys(replacements).forEach(placeholder => {
                translation = translation.replace(`{${placeholder}}`, replacements[placeholder]);
            });
            return translation;
        }, [language]);
        return <LanguageContext.Provider value={{ language, setLanguage, t }}>{children}</LanguageContext.Provider>;
      };
      const useLanguage = () => useContext(LanguageContext);

      // --- INLINED: components/icons.tsx ---
      const BrainSalutingIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" {...props}> <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1.5 14.5c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3-4c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm2.5-1.5c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm1-5.5H11v-1h3.5c.83 0 1.5.67 1.5 1.5v1zM9.5 11c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/> </svg> );
      const FlagIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M3 3v1.5M3 21v-6m0 0l2.77-.693a9 9 0 016.208.682l.108.054a9 9 0 006.086.71l3.114-.732a48.524 48.524 0 01-.005-10.499l-3.11.732a9 9 0 01-6.085-.711l-.108-.054a9 9 0 00-6.208-.682L3 4.5M3 4.5v.75m0 10.5v.75m18-11.25v.75m0 10.5v.75M4.5 10.5a1.5 1.5 0 113 0v3a1.5 1.5 0 01-3 0v-3z" /></svg>);
      const ArrowPathIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.667 0l3.181-3.183m-11.667-11.667a8.25 8.25 0 0111.667 0l3.181 3.183m-14.85-3.183L2.985 16.24z" /> </svg> );
      const ArrowUturnLeftIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}> <path strokeLinecap="round" strokeLinejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3" /> </svg> );
      const AcademicCapIcon = (props) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" {...props}><path d="M3.375 3C2.339 3 1.5 3.84 1.5 4.875v.75c0 1.036.84 1.875 1.875 1.875h17.25c1.035 0 1.875-.84 1.875-1.875v-.75C22.5 3.839 21.66 3 20.625 3H3.375z" /><path fillRule="evenodd" d="M3.087 9l.54 9.176A3 3 0 006.62 21h10.757a3 3 0 002.995-2.824L20.913 9H3.087zm6.163 3.75A.75.75 0 0110 12h4a.75.75 0 010 1.5h-4a.75.75 0 01-.75-.75z" clipRule="evenodd" /></svg>);
      
      // --- INLINED: services/dataService.ts ---
      const DB_KEY = 'playtest_db_v3';
      const getDatabase = () => JSON.parse(localStorage.getItem(DB_KEY) || '{}');
      const saveDatabase = (db) => localStorage.setItem(DB_KEY, JSON.stringify(db));
      const simulateDelay = (data, delay = 50) => new Promise(resolve => setTimeout(() => resolve(JSON.parse(JSON.stringify(data))), delay));
      const dataService = {
          fetchAllBlocks: async () => simulateDelay((getDatabase().globalBlocks || []).map(b => ({...b, questions: (getDatabase().globalQuestions || []).filter(q => q.bloqueId === b.id)}))),
          fetchGame: async (gameId) => simulateDelay((getDatabase().globalGames || []).find(g => g.id === gameId)),
          deleteGame: async (gameId) => {
              const db = getDatabase();
              db.globalGames = (db.globalGames || []).filter(g => g.id !== gameId);
              saveDatabase(db);
              return simulateDelay({ message: 'Game deleted' });
          },
          updateGame: async (gameId, updatedData) => {
              const db = getDatabase();
              const gameIndex = (db.globalGames || []).findIndex(g => g.id === gameId);
              if (gameIndex > -1) {
                  db.globalGames[gameIndex] = { ...db.globalGames[gameIndex], ...updatedData };
                  saveDatabase(db);
                  return simulateDelay(db.globalGames[gameIndex]);
              }
              return null;
          },
          updateUserStats: async (userId, gameId, gameResults, gameModeName) => {
              const db = getDatabase();
              const profile = db.userProfiles[userId];
              if (!profile) return;
      
              if (!profile.stats) profile.stats = {};
              if (!profile.answerHistory) profile.answerHistory = [];
              if (!profile.stats.consolidation) {
                  profile.stats.consolidation = { byQuestion: {}, byTopic: {}, byBlock: {} };
              }
              
              for (const answer of gameResults.answers) {
                  const { blockId, questionId, topicName, result, responseTime } = answer;
                  if (!blockId || !questionId) continue;
                  
                  profile.answerHistory.unshift({
                      gameId, questionId, blockId, topicName, result,
                      responseTime, timestamp: new Date().toISOString(),
                  });
              }

              const allGlobalQuestions = db.globalQuestions || [];
              const blockIdsInGame = new Set(gameResults.answers.map(a => a.blockId).filter(Boolean));

              for (const blockId of blockIdsInGame) {
                  const questionsInBlock = allGlobalQuestions.filter(q => q.bloqueId === blockId);
                  if (questionsInBlock.length === 0) continue;

                  const correctlyAnsweredIdsInBlock = new Set(
                      profile.answerHistory
                          .filter(h => h.blockId === blockId && h.result === 'ACIERTO')
                          .map(h => h.questionId)
                  );
                  const blockConsolidation = (correctlyAnsweredIdsInBlock.size / questionsInBlock.length) * 100;
                  profile.stats.consolidation.byBlock[blockId] = blockConsolidation;

                  const topicsInBlock = [...new Set(questionsInBlock.map(q => q.tema).filter(Boolean))];
                  
                  for (const topicName of topicsInBlock) {
                      const questionsInTopic = questionsInBlock.filter(q => q.tema === topicName);
                      if (questionsInTopic.length === 0) continue;

                      const correctlyAnsweredIdsInTopic = new Set(
                          profile.answerHistory
                              .filter(h => h.blockId === blockId && h.topicName === topicName && h.result === 'ACIERTO')
                              .map(h => h.questionId)
                      );
                      const topicConsolidation = (correctlyAnsweredIdsInTopic.size / questionsInTopic.length) * 100;
                      const topicKey = `${blockId}_${topicName}`;
                      profile.stats.consolidation.byTopic[topicKey] = topicConsolidation;
                  }
              }

              if (!profile.gameHistory) {
                  profile.gameHistory = [];
              }
              const correct = gameResults.answers.filter(a => a.result === 'ACIERTO' || a.isCorrect === true).length;
              const incorrect = gameResults.answers.filter(a => a.result === 'FALLO' || a.isCorrect === false).length;
              
              const blockIds = [...new Set(gameResults.answers.map(a => a.blockId))];
              const blockNames = (db.globalBlocks || [])
                  .filter(b => blockIds.includes(b.id))
                  .map(b => b.nombreCorto)
                  .join(', ');

              const historyEntry = {
                  gameId,
                  blockName: blockNames || 'N/A',
                  mode: gameModeName,
                  correct,
                  incorrect,
                  date: new Date().toISOString(),
              };

              if(gameResults.opponent) historyEntry.opponent = gameResults.opponent;
              if(gameResults.score !== undefined) historyEntry.score = gameResults.score;

              profile.gameHistory.unshift(historyEntry);
              if (profile.gameHistory.length > 10) {
                  profile.gameHistory = profile.gameHistory.slice(0, 10);
              }
      
              saveDatabase(db);
              return simulateDelay({ success: true });
          },
      };

      // --- INLINED: auth ---
      const UserContext = createContext();
      const useUser = () => useContext(UserContext);
      const UserProvider = ({ children }) => {
        const [currentUser, setCurrentUser] = useState(null);
        const [isLoading, setIsLoading] = useState(true);
        useEffect(() => { try { const s = localStorage.getItem('playtest_session'); if (s) { const ses = JSON.parse(s); if (ses?.userId) { const user = (getDatabase().users || []).find(u => u.id === ses.userId); if (user) setCurrentUser(user); else localStorage.removeItem('playtest_session'); } } } catch (e) { console.error("Session parse error", e); } setIsLoading(false); }, []);
        if (isLoading) return <div className="flex justify-center items-center h-screen"><svg className="animate-spin h-10 w-10 text-brand-cta" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" className="opacity-25"></circle><path d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" fill="currentColor" className="opacity-75"></path></svg></div>;
        if (!currentUser) { window.location.href = 'index.html'; return null; }
        return <UserContext.Provider value={{ currentUser }}>{children}</UserContext.Provider>;
      }

      // --- INLINED: components ---
       const ConfirmationDialog = ({ title, message, confirmText, cancelText, onConfirm, onCancel, danger = false }) => (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in" onClick={onCancel}>
          <div className={`bg-brand-secondary rounded-xl shadow-2xl w-full max-w-sm m-4 border ${danger ? 'border-brand-danger/50' : 'border-brand-tertiary'} p-6 text-center`} onClick={e => e.stopPropagation()}>
              <h4 className="text-xl font-bold text-brand-light">{title}</h4>
              <p className="text-brand-accent my-4">{message}</p>
              <div className="flex justify-center gap-4 mt-6">
                  <button onClick={onCancel} className="py-2 px-6 rounded-lg bg-brand-tertiary hover:bg-brand-accent text-brand-light font-bold transition-colors">{cancelText}</button>
                  <button onClick={onConfirm} className={`py-2 px-6 rounded-lg font-bold transition-colors text-white ${danger ? 'bg-brand-danger hover:bg-red-500' : 'bg-brand-cta hover:bg-brand-cta-hover'}`}>{confirmText}</button>
              </div>
          </div>
        </div>
      );
      
      const Header = () => {
        const { t } = useLanguage();
        return (
          <header className="bg-brand-secondary shadow-lg"><div className="container mx-auto px-4 sm:px-6 lg:px-8"><div className="flex items-center justify-between h-16">
              <div className="flex items-center space-x-3"><BrainSalutingIcon className="h-8 w-8 text-brand-cta" /><h1 className="text-xl md:text-2xl font-bold tracking-wider text-brand-light">{t('header_title')}</h1></div>
          </div></div></header>
        );
      };

      const TrivialGameComponent = ({ initialGame, questions }) => {
          const { t } = useLanguage();
          const { currentUser } = useUser();
          
          const [game, setGame] = useState(initialGame);
          const [isConfirmingFinish, setIsConfirmingFinish] = useState(false);
          const questionStartTime = useRef(Date.now());
          const gameStartTime = useRef(initialGame.startTime || Date.now());

          const { allTopics, questionsByTopic, topicColors } = useMemo(() => {
            const topics = [...new Set(questions.map(q => q.tema).filter(Boolean))].sort();
            const qByTopic = {};
            const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#78716c', '#f43f5e'];
            const tColors = {};
            const askedIds = new Set(game.askedQuestionIds || []);
            topics.forEach((topic, i) => {
              qByTopic[topic] = questions.filter(q => q.tema === topic && !askedIds.has(q.id));
              tColors[topic] = colors[i % colors.length];
            });
            return { allTopics, questionsByTopic, topicColors };
          }, [questions, game.askedQuestionIds]);

          const isMyTurn = currentUser.id === game.players[game.turn].userId;
          
           useEffect(() => {
                if (game.gameState === 'finished' && currentUser) {
                    const winnerIndex = Object.values(game.playerWedges).findIndex(wedges => wedges.length === allTopics.length);
                    const amITheOneToCleanUp = winnerIndex === -1 ? game.turn === 0 : game.players[winnerIndex].userId === currentUser.id;
                    
                    if (amITheOneToCleanUp) {
                        game.players.forEach(async (player, playerIndex) => {
                            const playerAnswers = (game.history || []).filter(h => h.playerIndex === playerIndex);
                            if (playerAnswers.length > 0) {
                                const gameResults = {
                                    answers: playerAnswers.map(ans => ({ ...ans, result: ans.isCorrect ? 'ACIERTO' : 'FALLO' })),
                                    opponent: game.players.find(p => p.userId !== player.userId)?.nickname
                                };
                                await dataService.updateUserStats(player.userId, game.id, gameResults, game.mode);
                            }
                        });
                        dataService.deleteGame(game.id);
                    }
                }
            }, [game, currentUser, allTopics.length]);

          const handleTopicSelect = (topic) => {
            if (!isMyTurn || questionsByTopic[topic]?.length === 0) return;
            const question = questionsByTopic[topic][Math.floor(Math.random() * questionsByTopic[topic].length)];
            const updatedAskedIds = [...(game.askedQuestionIds || []), question.id];
            
            const updatedGame = { ...game, gameState: 'question', currentQuestion: question, selectedTopic: topic, askedQuestionIds: updatedAskedIds };
            setGame(updatedGame);
            dataService.updateGame(game.id, updatedGame);
            questionStartTime.current = Date.now();
          };
          
          const handleAnswerSelect = (answerIndex) => {
            const isCorrect = game.currentQuestion.respuestas[answerIndex].esCorrecta;
            
            const responseTime = (Date.now() - questionStartTime.current) / 1000;
            
            const currentPlayer = game.turn;
            const nextPlayer = isCorrect ? currentPlayer : (currentPlayer + 1) % 2;
            const nextRound = currentPlayer === 1 ? game.round + 1 : game.round;

            const newHistoryEntry = {
                playerIndex: currentPlayer,
                questionId: game.currentQuestion.id, isCorrect, topic: game.selectedTopic,
                blockId: game.currentQuestion.blockId, topicName: game.currentQuestion.tema,
                responseTime,
            };
            const updatedHistory = [...(game.history || []), newHistoryEntry];
            
            let newWedgeEarned = false;
            let newPlayerWedges = {...game.playerWedges};

            if (isCorrect) {
              const currentPlayerWedges = new Set(game.playerWedges[currentPlayer]);
              if (!currentPlayerWedges.has(game.selectedTopic)) {
                currentPlayerWedges.add(game.selectedTopic);
                newPlayerWedges = { ...game.playerWedges, [currentPlayer]: Array.from(currentPlayerWedges) };
                newWedgeEarned = true;
                if (currentPlayerWedges.size === allTopics.length) {
                  const finalState = { ...game, gameState: 'finished', playerWedges: newPlayerWedges, history: updatedHistory, totalTurns: (game.totalTurns || 0) + 1, round: nextRound };
                  setGame(finalState);
                  dataService.updateGame(game.id, finalState);
                  return;
                }
              }
            }
            
            const totalTurns = (game.totalTurns || 0) + 1;
            const updatedGame = { ...game, gameState: 'feedback', feedback: { type: isCorrect ? 'correct' : 'incorrect', newWedge: newWedgeEarned }, playerWedges: newPlayerWedges, turn: nextPlayer, totalTurns, round: nextRound, history: updatedHistory };
            setGame(updatedGame);
            dataService.updateGame(game.id, updatedGame);
          };

          const handleContinue = () => {
            const updatedGame = { ...game, gameState: 'topic_selection', feedback: null, currentQuestion: null, selectedTopic: null };
            setGame(updatedGame);
            dataService.updateGame(game.id, updatedGame);
          };

          const handleFinish = () => {
            const finalState = {...game, gameState: 'finished'};
            setGame(finalState);
            dataService.updateGame(game.id, finalState);
          };
          
          if (game.gameState === 'finished') {
              const winnerIndex = Object.values(game.playerWedges).findIndex(wedges => wedges.length === allTopics.length);
              const winner = winnerIndex !== -1 ? game.players[winnerIndex] : null;
              
              const stats = game.players.map((player, index) => {
                  const playerHistory = (game.history || []).filter(h => h.playerIndex === index);
                  const topicCounts = playerHistory.reduce((acc, h) => {
                      if(!acc[h.topic]) acc[h.topic] = { correct: 0, incorrect: 0 };
                      if(h.isCorrect) acc[h.topic].correct++; else acc[h.topic].incorrect++;
                      return acc;
                  }, {});
                  return {
                      wedges: game.playerWedges[index].length,
                      mostHit: Object.entries(topicCounts).sort((a,b) => b[1].correct - a[1].correct)[0]?.[0] || 'N/A',
                      mostMissed: Object.entries(topicCounts).sort((a,b) => b[1].incorrect - a[1].incorrect)[0]?.[0] || 'N/A'
                  };
              });
              
              const totalTime = Math.floor((Date.now() - gameStartTime.current) / 1000);
              const formatTime = (s) => `${Math.floor(s/60)}m ${s%60}s`;

              return (
                <div className="max-w-3xl mx-auto animate-fade-in p-8 bg-brand-secondary rounded-xl">
                    <h2 className="text-4xl font-bold text-brand-light mb-2 text-center">{t('game_results_title')}</h2>
                    {winner && <h3 className="text-2xl font-semibold text-brand-cta mb-6 text-center">{t('game_winner_announcement', { nickname: winner.nickname })}</h3>}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 text-center mb-6">
                        {game.players.map((p, i) => (
                            <div key={p.userId} className="bg-brand-primary p-4 rounded-lg">
                                <h4 className="font-bold text-xl text-brand-light mb-3">{p.nickname}</h4>
                                <p className="text-brand-accent">{t('game_stats_wedges')}: <span className="font-bold text-white">{stats[i].wedges} / {allTopics.length}</span></p>
                                <p className="text-brand-accent">{t('game_stats_most_hit_topic')}: <span className="font-bold text-white">{stats[i].mostHit}</span></p>
                                <p className="text-brand-accent">{t('game_stats_most_missed_topic')}: <span className="font-bold text-white">{stats[i].mostMissed}</span></p>
                            </div>
                        ))}
                    </div>
                    <div className="text-center text-brand-accent bg-brand-primary p-4 rounded-lg mb-8">
                      <p>{t('game_stats_rounds')}: <span className="font-bold text-white">{game.round || 0}</span> | {t('game_stats_turns')}: <span className="font-bold text-white">{game.totalTurns || 0}</span> | {t('game_stats_total_time')}: <span className="font-bold text-white">{formatTime(totalTime)}</span></p>
                    </div>
                    <div className="flex justify-center gap-4">
                      <button onClick={() => window.location.reload()} className="flex items-center gap-2 bg-brand-tertiary hover:bg-brand-accent text-brand-light font-bold py-3 px-6 rounded-lg transition-colors"><ArrowPathIcon className="h-5 w-5" />{t('game_button_play_again')}</button>
                      <button onClick={() => window.location.href = 'index.html'} className="flex items-center gap-2 bg-brand-cta hover:bg-brand-cta-hover text-white font-bold py-3 px-6 rounded-lg transition-colors"><ArrowUturnLeftIcon className="h-5 w-5" />{t('game_button_dashboard')}</button>
                    </div>
                </div>
              );
          }

          const renderPlayerStatus = (playerNum) => (
            <div className={`p-4 rounded-lg border-2 ${game.turn === playerNum ? 'border-brand-cta bg-brand-primary' : 'border-transparent'}`}>
              <h3 className="text-lg font-bold text-center mb-3 truncate">{game.players[playerNum].nickname}</h3>
              <div className="grid grid-cols-3 gap-2">
                {allTopics.map(topic => (
                  <div key={topic} title={topic} className={`h-10 w-10 rounded-full flex items-center justify-center transition-all ${(game.playerWedges[playerNum] || []).includes(topic) ? 'opacity-100' : 'opacity-25'}`} style={{backgroundColor: topicColors[topic]}}>
                    <AcademicCapIcon className="h-6 w-6 text-white"/>
                  </div>
                ))}
              </div>
            </div>
          );

          return (
            <div className="max-w-6xl mx-auto animate-fade-in">
              {isConfirmingFinish && ( <ConfirmationDialog title={t('game_finish_confirm_title')} message={t('game_finish_confirm_message')} confirmText={t('game_button_finish')} cancelText={t('generic_cancel')} onConfirm={handleFinish} onCancel={() => setIsConfirmingFinish(false)} danger={true}/> )}

              <div className="flex justify-between items-center mb-4">
                <h2 className="text-2xl font-bold text-brand-light">{game.mode}</h2>
                <button onClick={() => setIsConfirmingFinish(true)} className="flex items-center gap-2 text-sm bg-brand-danger/80 hover:bg-brand-danger text-white font-semibold py-2 px-4 rounded-lg transition-colors"> <FlagIcon className="h-5 w-5" /> {t('game_button_finish')} </button>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div className="md:col-span-1 bg-brand-secondary p-4 rounded-xl flex flex-col gap-6">{renderPlayerStatus(0)} {renderPlayerStatus(1)}</div>
                <div className="md:col-span-3 bg-brand-secondary p-6 rounded-xl min-h-[30rem] flex flex-col justify-center">
                  {game.gameState === 'topic_selection' && (
                    <div className="animate-fade-in">
                      <h3 className="text-2xl font-bold text-center text-brand-light mb-6">{t('game_player_turn', {playerNickname: game.players[game.turn].nickname})}: <span className="text-brand-accent font-medium">{t('game_choose_topic')}</span></h3>
                       {!isMyTurn && <p className="text-center text-brand-accent">Esperando al oponente...</p>}
                      <div className="grid grid-cols-2 lg:grid-cols-3 gap-4">
                        {allTopics.map(topic => {
                            const hasWedge = (game.playerWedges[game.turn] || []).includes(topic);
                            const hasQuestions = questionsByTopic[topic]?.length > 0;
                            return (
                                <button key={topic} onClick={() => handleTopicSelect(topic)} disabled={!isMyTurn || hasWedge || !hasQuestions} style={{backgroundColor: topicColors[topic]}} className={`p-4 h-24 rounded-lg text-white font-bold text-lg flex items-center justify-center text-center transition-transform transform ${!hasWedge && 'hover:scale-105'} disabled:opacity-50 disabled:transform-none disabled:cursor-not-allowed`}>
                                    {topic}
                                </button>
                            );
                        })}
                      </div>
                    </div>
                  )}
                  {game.gameState === 'question' && game.currentQuestion && (
                    <div className="animate-fade-in">
                      <p className="text-center font-bold mb-4" style={{color: topicColors[game.selectedTopic]}}>{game.selectedTopic}</p>
                      <div className="bg-brand-primary p-6 rounded-lg mb-6 min-h-[120px] flex items-center justify-center">
                        <p className="text-xl sm:text-2xl font-semibold text-brand-light leading-relaxed text-center">{game.currentQuestion.textoPregunta}</p>
                      </div>
                      <fieldset className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <legend className="sr-only">{t('game_select_answer')}</legend>
                        {game.currentQuestion.respuestas.map((answer, index) => (
                           <button key={index} onClick={() => handleAnswerSelect(index)} disabled={!isMyTurn} className="w-full text-left p-4 rounded-lg text-brand-light font-medium transition-all bg-brand-tertiary hover:bg-brand-accent disabled:opacity-50 disabled:cursor-not-allowed"> {answer.textoRespuesta} </button>
                        ))}
                      </fieldset>
                    </div>
                  )}
                  {game.gameState === 'feedback' && game.feedback && (
                     <div className="flex flex-col items-center justify-center text-center h-full animate-pop-in">
                        <h3 className={`text-3xl font-bold ${game.feedback.type === 'correct' ? 'text-brand-success' : 'text-brand-danger'}`}>{t(`game_feedback_${game.feedback.type}`)}</h3>
                        {game.feedback.newWedge && <p className="text-xl text-brand-cta mt-2">{t('game_wedge_earned')}</p>}
                        <p className="text-lg text-brand-accent mt-4">{game.feedback.type === 'correct' ? t('game_turn_again') : t('game_turn_ends')}</p>
                        <button onClick={handleContinue} className="mt-8 bg-brand-cta hover:bg-brand-cta-hover text-white font-bold py-2 px-8 rounded-lg transition-colors">{t('game_continue_button')}</button>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
      };

      const TrivialGamePageContent = () => {
          const { t } = useLanguage();
          const [game, setGame] = useState(null);
          const [blocks, setBlocks] = useState([]);
          const [isLoading, setIsLoading] = useState(true);
          const [error, setError] = useState(null);

          useEffect(() => {
              const params = new URLSearchParams(window.location.search);
              const gameId = params.get('gameId');
              if (!gameId) { setError("No game ID provided."); setIsLoading(false); return; }

              const loadData = async () => {
                  try {
                       const [fetchedGame, fetchedBlocks] = await Promise.all([ 
                          dataService.fetchGame(gameId), 
                          dataService.fetchAllBlocks() 
                        ]);
                      if (!fetchedGame) throw new Error("Game not found or has been declined.");
                      const initialisedGame = { 
                          ...fetchedGame,
                          gameState: fetchedGame.gameState || 'topic_selection',
                          turn: fetchedGame.turn || 0,
                          playerWedges: fetchedGame.playerWedges || {0: [], 1: []},
                          askedQuestionIds: fetchedGame.askedQuestionIds || [],
                          history: fetchedGame.history || [],
                          round: fetchedGame.round || 0,
                          totalTurns: fetchedGame.totalTurns || 0,
                          startTime: fetchedGame.startTime || Date.now()
                      };
                      setGame(initialisedGame);
                      setBlocks(fetchedBlocks);
                  } catch (err) { setError(err.message);
                  } finally { setIsLoading(false); }
              };
              loadData();
          }, []);
          
          const gameQuestions = useMemo(() => {
              if (!game || !game.config || !blocks || blocks.length === 0) return [];
              let questions = [];
              for (const [blockId, blockConfig] of Object.entries(game.config)) {
                  const block = blocks.find(b => b.id === blockId);
                  if (!block || !block.questions) continue;
                  const questionsWithMeta = block.questions.map(q => ({...q, blockId: block.id }));
                  if (blockConfig.topics === 'all') { questions.push(...questionsWithMeta); } 
                  else if (Array.isArray(blockConfig.topics)) { questions.push(...questionsWithMeta.filter(q => blockConfig.topics.includes(q.tema))); }
              }
              return questions;
          }, [game, blocks]);

          const renderContent = () => {
              if (isLoading) { return <div className="flex justify-center items-center h-64"><svg className="animate-spin h-10 w-10 text-brand-cta" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>; }
              if (error) { return <div className="text-center text-brand-danger bg-red-500/10 p-4 rounded-lg">{t('error')}: {error}</div>; }
              if (game.status === 'pending') { return <div className="text-center text-brand-accent p-8">Esperando a que el oponente acepte el reto...</div> }
              if ([...new Set(gameQuestions.map(q => q.tema))].length < 2) { return <div className="text-center text-brand-accent p-8">No hay suficientes temas diferentes para una partida de Trivial (se necesitan al menos 2).</div> }
              return <TrivialGameComponent initialGame={game} questions={gameQuestions} />;
          };

          return (
              <div className="min-h-screen flex flex-col">
                  <Header />
                  <main className="flex-grow p-4 sm:p-6 lg:p-8">{renderContent()}</main>
                  <footer className="text-center p-4 text-xs text-brand-accent"><p>{t('footer_text')}</p></footer>
              </div>
          );
      };

      const TrivialGameApp = () => ( <UserProvider> <TrivialGamePageContent /> </UserProvider> );

      // --- App Entry Point ---
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render( <React.StrictMode> <LanguageProvider><TrivialGameApp /></LanguageProvider> </React.StrictMode> );
    </script>
    <noscript>This application requires JavaScript to run.</noscript>
  </body>
</html>